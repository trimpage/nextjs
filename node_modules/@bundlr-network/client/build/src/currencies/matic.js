"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maticGetPublicKey = exports.maticSendTx = exports.maticCreateTx = exports.maticGetFee = exports.maticGetHeight = exports.maticGetTx = exports.maticOwnerToAddress = exports.maticVerify = exports.maticGetSigner = exports.maticSign = void 0;
const tslib_1 = require("tslib");
const PolygonSigner_1 = (0, tslib_1.__importDefault)(require("arbundles/build/signing/chains/PolygonSigner"));
const index_1 = require("./index");
const keccak256_1 = (0, tslib_1.__importDefault)(require("keccak256"));
const secp256k1_1 = require("secp256k1");
const ethers_1 = require("ethers");
const bignumber_js_1 = (0, tslib_1.__importDefault)(require("bignumber.js"));
function maticSign(message) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const signer = new PolygonSigner_1.default(index_1.currencies["matic"].account.key);
        return signer.sign(message);
    });
}
exports.maticSign = maticSign;
function maticGetSigner() {
    return new PolygonSigner_1.default(index_1.currencies["matic"].account.key);
}
exports.maticGetSigner = maticGetSigner;
function maticVerify(pub, data, sig) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return PolygonSigner_1.default.verify(pub, data, sig);
    });
}
exports.maticVerify = maticVerify;
function maticOwnerToAddress(owner) {
    return "0x" + (0, keccak256_1.default)(owner.slice(1)).slice(-20).toString("hex");
}
exports.maticOwnerToAddress = maticOwnerToAddress;
function maticGetTx(txId) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(index_1.currencies["matic"].provider);
        const response = yield provider.getTransaction(txId);
        if (!response)
            throw new Error("Tx doesn't exist");
        return {
            from: response.from,
            to: response.to,
            blockHeight: new bignumber_js_1.default(response.blockNumber),
            amount: new bignumber_js_1.default(response.value.toHexString(), 16),
            pending: !response.blockHash,
            confirmed: response.confirmations >= 10
        };
    });
}
exports.maticGetTx = maticGetTx;
function maticGetHeight() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(index_1.currencies["matic"].provider);
        const response = yield provider.send("eth_blockNumber", []);
        return new bignumber_js_1.default(response, 16);
    });
}
exports.maticGetHeight = maticGetHeight;
function maticGetFee(amount, to) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(index_1.currencies["matic"].provider);
        yield provider._ready();
        const tx = {
            to,
            value: "0x" + amount.toString(16)
        };
        const estimatedGas = yield provider.estimateGas(tx);
        const gasPrice = yield provider.getGasPrice();
        return new bignumber_js_1.default(estimatedGas.mul(gasPrice).toString());
    });
}
exports.maticGetFee = maticGetFee;
function maticCreateTx(amount, to, _fee) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const provider = new ethers_1.ethers.providers.JsonRpcProvider(index_1.currencies["matic"].provider);
        const key = index_1.currencies["matic"].account.key;
        yield provider._ready();
        const wallet = new ethers_1.Wallet(key, provider);
        let bigNumberAmount;
        if (bignumber_js_1.default.isBigNumber(amount)) {
            bigNumberAmount = amount;
        }
        else {
            bigNumberAmount = new bignumber_js_1.default(amount);
        }
        const _amount = "0x" + bigNumberAmount.toString(16);
        const estimatedGas = yield provider.estimateGas({ to, value: _amount });
        const gasPrice = yield provider.getGasPrice();
        const tx = yield wallet.populateTransaction({
            to,
            value: _amount,
            gasPrice,
            gasLimit: estimatedGas
        });
        const signedTx = yield wallet.signTransaction(tx);
        const txId = "0x" + (0, keccak256_1.default)(Buffer.from(signedTx.slice(2), "hex")).toString("hex");
        return { txId, tx: signedTx };
    });
}
exports.maticCreateTx = maticCreateTx;
function maticSendTx(tx) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        try {
            const provider = new ethers_1.ethers.providers.JsonRpcProvider(index_1.currencies["matic"].provider);
            yield provider._ready();
            yield provider.sendTransaction(tx);
        }
        catch (e) {
            console.error(`Error occurred while sending a MATIC tx - ${e}`);
            throw e;
        }
    });
}
exports.maticSendTx = maticSendTx;
function maticGetPublicKey() {
    return Buffer.from((0, secp256k1_1.publicKeyCreate)(Buffer.from(index_1.currencies["matic"].account.key, "hex"), false));
}
exports.maticGetPublicKey = maticGetPublicKey;
//# sourceMappingURL=matic.js.map