"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.solanaGetSigner = exports.solanaGetTx = exports.solanaCreateTx = exports.solanaSendTx = exports.solanaGetFee = exports.solanaGetCurrentHeight = exports.solanaGetPublicKey = exports.solanaOwnerToAddress = exports.solanaVerify = exports.solanaSign = void 0;
const tslib_1 = require("tslib");
const web3 = (0, tslib_1.__importStar)(require("@solana/web3.js"));
const index_1 = require("./index");
const SolanaSigner_1 = (0, tslib_1.__importDefault)(require("arbundles/build/signing/chains/SolanaSigner"));
require("bs58");
const tweetnacl_1 = (0, tslib_1.__importDefault)(require("tweetnacl"));
const bignumber_js_1 = (0, tslib_1.__importDefault)(require("bignumber.js"));
const bs58_1 = (0, tslib_1.__importDefault)(require("bs58"));
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
function createConnection() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return new web3.Connection(web3.clusterApiUrl(index_1.currencies["solana"].provider), "confirmed");
    });
}
function getKeyPair() {
    let key = index_1.currencies["solana"].account.key;
    if (typeof key !== "string") {
        key = bs58_1.default.encode(Buffer.from(key));
    }
    return web3.Keypair.fromSecretKey(bs58_1.default.decode(key));
}
// where data is tx.serialiseMessage() 
function solanaSign(data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        // const keyp = getKeyPair();
        // const keypb = Buffer.concat([keyp.publicKey.toBuffer(), keyp.secretKey])
        // const signer = new SolanaSigner(keypb.toString());
        return yield (yield solanaGetSigner()).sign(data);
    });
}
exports.solanaSign = solanaSign;
function solanaVerify(pub, data, sig) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        return SolanaSigner_1.default.verify(pub, data, sig);
    });
}
exports.solanaVerify = solanaVerify;
// assuming "owner" is the pubkey
function solanaOwnerToAddress(owner) {
    return bs58_1.default.encode(owner);
}
exports.solanaOwnerToAddress = solanaOwnerToAddress;
function solanaGetPublicKey() {
    // derive from privkey to ensure it's correct.
    const key = getKeyPair();
    //const key = web3.Keypair.fromSecretKey(bs58.decode(currencies["solana"].account.key));
    //return Buffer.from(key.publicKey.toBase58())
    return key.publicKey.toBuffer();
}
exports.solanaGetPublicKey = solanaGetPublicKey;
function solanaGetCurrentHeight() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const connection = yield createConnection();
        return new bignumber_js_1.default((yield connection.getEpochInfo()).blockHeight);
    });
}
exports.solanaGetCurrentHeight = solanaGetCurrentHeight;
//this function gives the fee for a *single* signature
function solanaGetFee(_amount, _to) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const connection = yield createConnection();
        const block = yield connection.getRecentBlockhash();
        const feeCalc = yield connection.getFeeCalculatorForBlockhash(block.blockhash);
        return new bignumber_js_1.default(feeCalc.value.lamportsPerSignature);
    });
}
exports.solanaGetFee = solanaGetFee;
function solanaSendTx(tx) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const connection = yield createConnection();
        let res;
        // if it's already been signed...
        if (tx.signature) {
            res = web3.sendAndConfirmRawTransaction(connection, tx.serialize());
        }
        else {
            res = web3.sendAndConfirmTransaction(connection, tx, [getKeyPair()]);
        }
        yield sleep(1000); // sleep so the chain has enough time to sync so the bundler doesn't erroneously reject.
        return res;
    });
}
exports.solanaSendTx = solanaSendTx;
function solanaCreateTx(amount, to, _fee) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const connection = yield createConnection();
        // TODO: figure out how to manually set fees?
        // TODO: figure out how to get the txId at creation time
        //const key = currencies["solana"].account.key;
        const keys = yield getKeyPair();
        const transaction = new web3.Transaction({
            recentBlockhash: (yield connection.getRecentBlockhash()).blockhash,
            feePayer: keys.publicKey
        });
        transaction.add(web3.SystemProgram.transfer({
            fromPubkey: keys.publicKey,
            toPubkey: new web3.PublicKey(to),
            lamports: amount,
        }));
        const transactionBuffer = transaction.serializeMessage();
        const signature = tweetnacl_1.default.sign.detached(transactionBuffer, keys.secretKey);
        transaction.addSignature(keys.publicKey, Buffer.from(signature));
        return { tx: transaction, txId: bs58_1.default.encode(signature) };
    });
}
exports.solanaCreateTx = solanaCreateTx;
function solanaGetTx(txid) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
        const connection = yield createConnection();
        const stx = yield connection.getTransaction(txid, { commitment: "confirmed" });
        // why is this so convoluted ;-;
        const confirmed = !((yield connection.getTransaction(txid)) === null);
        const amount = new bignumber_js_1.default(stx.meta.postBalances[1]).minus(new bignumber_js_1.default(stx.meta.preBalances[1]));
        const tx = {
            from: stx.transaction.message.accountKeys[0].toBase58(),
            to: stx.transaction.message.accountKeys[1].toBase58(),
            amount: amount,
            pending: false,
            confirmed
        };
        return tx;
    });
}
exports.solanaGetTx = solanaGetTx;
function solanaGetSigner() {
    const keyp = getKeyPair();
    const keypb = bs58_1.default.encode(Buffer.concat([keyp.secretKey, keyp.publicKey.toBuffer()]));
    return new SolanaSigner_1.default(keypb);
}
exports.solanaGetSigner = solanaGetSigner;
//# sourceMappingURL=solana.js.map