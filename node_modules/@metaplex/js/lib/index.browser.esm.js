import { PublicKey, Transaction as Transaction$1, TransactionInstruction, SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY, SystemProgram, clusterApiUrl, Connection as Connection$1 } from '@solana/web3.js';
import { BinaryReader, BinaryWriter, serialize, deserializeUnchecked, deserialize as deserialize$3 } from 'borsh';
import bs58 from 'bs58';
import { sha256 } from 'crypto-hash';
import { Buffer as Buffer$1 } from 'buffer';
import BN from 'bn.js';
import { TOKEN_PROGRAM_ID, AccountLayout, u64, MintLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';
import axios from 'axios';

const extendBorsh = () => {
    BinaryReader.prototype.readPubkey = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return new PublicKey(array);
    };
    BinaryWriter.prototype.writePubkey = function (value) {
        const writer = this;
        writer.writeFixedArray(value.toBuffer());
    };
    BinaryReader.prototype.readPubkeyAsString = function () {
        const reader = this;
        const array = reader.readFixedArray(32);
        return bs58.encode(array);
    };
    BinaryWriter.prototype.writePubkeyAsString = function (value) {
        const writer = this;
        writer.writeFixedArray(bs58.decode(value));
    };
};
extendBorsh();
class Data {
    constructor(args = {}) {
        Object.assign(this, args);
    }
    static struct(fields) {
        return struct(this, fields);
    }
    static serialize(args = {}) {
        return Buffer.from(serialize(this.SCHEMA, new this(args)));
    }
    static deserialize(data) {
        return deserializeUnchecked(this.SCHEMA, this, data);
    }
}
const struct = (type, fields) => {
    return new Map([[type, { kind: 'struct', fields }]]);
};

var borsh = /*#__PURE__*/Object.freeze({
  __proto__: null,
  extendBorsh: extendBorsh,
  Data: Data,
  struct: struct,
  deserialize: deserialize$3,
  deserializeUnchecked: deserializeUnchecked,
  serialize: serialize
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

const getFileHash = (file) => __awaiter(void 0, void 0, void 0, function* () { return Buffer$1.from(yield sha256(file.toString())); });

var crypto = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getFileHash: getFileHash
});

var TupleNumericType;
(function (TupleNumericType) {
    TupleNumericType[TupleNumericType["U8"] = 1] = "U8";
    TupleNumericType[TupleNumericType["U16"] = 2] = "U16";
    TupleNumericType[TupleNumericType["U32"] = 4] = "U32";
    TupleNumericType[TupleNumericType["U64"] = 8] = "U64";
})(TupleNumericType || (TupleNumericType = {}));
const getBNFromData = (data, offset, dataType) => {
    switch (dataType) {
        case TupleNumericType.U8:
            return new BN(data[offset], 'le');
        case TupleNumericType.U16:
            return new BN(data.slice(offset, offset + 2), 'le');
        case TupleNumericType.U32:
            return new BN(data.slice(offset, offset + 4), 'le');
        case TupleNumericType.U64:
            return new BN(data.slice(offset, offset + 8), 'le');
    }
};

var index$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Borsh: borsh,
  Crypto: crypto,
  get TupleNumericType () { return TupleNumericType; },
  getBNFromData: getBNFromData
});

var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["ERROR_INVALID_OWNER"] = 0] = "ERROR_INVALID_OWNER";
    ErrorCode[ErrorCode["ERROR_INVALID_ACCOUNT_DATA"] = 1] = "ERROR_INVALID_ACCOUNT_DATA";
    ErrorCode[ErrorCode["ERROR_DEPRECATED_ACCOUNT_DATA"] = 2] = "ERROR_DEPRECATED_ACCOUNT_DATA";
})(ErrorCode || (ErrorCode = {}));
class MetaplexError extends Error {
    constructor(errorCode, message) {
        super(message);
        this.errorCode = errorCode;
    }
}
const ERROR_INVALID_OWNER = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_OWNER, 'Invalid owner');
};
const ERROR_INVALID_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_INVALID_ACCOUNT_DATA, 'Invalid data');
};
const ERROR_DEPRECATED_ACCOUNT_DATA = () => {
    return new MetaplexError(ErrorCode.ERROR_DEPRECATED_ACCOUNT_DATA, 'Account data is deprecated');
};

var errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  get ErrorCode () { return ErrorCode; },
  MetaplexError: MetaplexError,
  ERROR_INVALID_OWNER: ERROR_INVALID_OWNER,
  ERROR_INVALID_ACCOUNT_DATA: ERROR_INVALID_ACCOUNT_DATA,
  ERROR_DEPRECATED_ACCOUNT_DATA: ERROR_DEPRECATED_ACCOUNT_DATA
});

class Transaction extends Transaction$1 {
    constructor(options) {
        super(options);
    }
    static fromCombined(transactions, options = {}) {
        const combinedTransaction = new Transaction(options);
        transactions.forEach((transaction) => transaction.instructions.forEach((instruction) => {
            combinedTransaction.add(instruction);
        }));
        return combinedTransaction;
    }
}

const sendTransaction = ({ connection, wallet, txs, signers = [], options, }) => __awaiter(void 0, void 0, void 0, function* () {
    let tx = Transaction.fromCombined(txs, { feePayer: wallet.publicKey });
    tx.recentBlockhash = (yield connection.getRecentBlockhash()).blockhash;
    if (signers.length) {
        tx.partialSign(...signers);
    }
    tx = yield wallet.signTransaction(tx);
    return connection.sendRawTransaction(tx.serialize(), options);
});

class Account {
    constructor(pubkey, info) {
        this.pubkey = new PublicKey(pubkey);
        this.info = info;
    }
    static from(account) {
        return new this(account.pubkey, account.info);
    }
    static load(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield Account.getInfo(connection, pubkey);
            return new this(pubkey, info);
        });
    }
    static isCompatible(data) {
        throw new Error(`method 'isCompatible' is not implemented`);
    }
    static getInfo(connection, pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = yield connection.getAccountInfo(new PublicKey(pubkey));
            if (!info) {
                throw new Error(`Unable to find account: ${pubkey}`);
            }
            return Object.assign(Object.assign({}, info), { data: Buffer$1.from(info === null || info === void 0 ? void 0 : info.data) });
        });
    }
    static getInfos(connection, pubkeys, commitment = 'recent') {
        return __awaiter(this, void 0, void 0, function* () {
            const BATCH_SIZE = 99;
            const promises = [];
            for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
                promises.push(Account.getMultipleAccounts(connection, pubkeys.slice(i, Math.min(pubkeys.length, i + BATCH_SIZE)), commitment));
            }
            const results = new Map();
            (yield Promise.all(promises)).forEach((result) => { var _a; return [...((_a = result === null || result === void 0 ? void 0 : result.entries()) !== null && _a !== void 0 ? _a : [])].forEach(([k, v]) => results.set(k, v)); });
            return results;
        });
    }
    static getMultipleAccounts(connection, pubkeys, commitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = connection._buildArgs([pubkeys.map((k) => k.toString())], commitment, 'base64');
            const unsafeRes = yield connection._rpcRequest('getMultipleAccounts', args);
            if (unsafeRes.error) {
                throw new Error('failed to get info about accounts ' + unsafeRes.error.message);
            }
            if (!unsafeRes.result.value)
                return;
            const infos = unsafeRes.result.value.map((info) => (Object.assign(Object.assign({}, info), { data: Buffer$1.from(info.data[0], 'base64') })));
            return infos.reduce((acc, info, index) => {
                acc.set(pubkeys[index], info);
                return acc;
            }, new Map());
        });
    }
    assertOwner(pubkey) {
        var _a;
        return (_a = this.info) === null || _a === void 0 ? void 0 : _a.owner.equals(new PublicKey(pubkey));
    }
    toJSON() {
        var _a, _b, _c, _d, _e;
        return {
            pubkey: this.pubkey.toString(),
            info: {
                executable: !!((_a = this.info) === null || _a === void 0 ? void 0 : _a.executable),
                owner: ((_b = this.info) === null || _b === void 0 ? void 0 : _b.owner) ? new PublicKey((_c = this.info) === null || _c === void 0 ? void 0 : _c.owner) : null,
                lamports: (_d = this.info) === null || _d === void 0 ? void 0 : _d.lamports,
                data: (_e = this.info) === null || _e === void 0 ? void 0 : _e.data.toJSON(),
            },
            data: this.data,
        };
    }
    toString() {
        return JSON.stringify(this.toJSON());
    }
}

const config = {
    arweaveWallet: 'HvwC9QSAzvGXhhVrgPmauVwFWcYZhne3hVot9EbHuFTm',
    programs: {
        auction: 'auctxRXPeJoc4817jDhf4HbjnhEcr1cCXenosMhK5R8',
        metadata: 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
        metaplex: 'p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98',
        vault: 'vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn',
        packs: 'BNRmGgciUJuyznkYHnmitA9an1BcDDiU9JmjEQwvBYVR',
        memo: 'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',
    },
    maxCreatorLimit: 5,
};

class Program {
    static findProgramAddress(seeds) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield PublicKey.findProgramAddress(seeds, this.PUBKEY))[0];
        });
    }
    static getProgramAccounts(connection, configOrCommitment) {
        return __awaiter(this, void 0, void 0, function* () {
            const extra = {};
            let commitment;
            if (configOrCommitment) {
                if (typeof configOrCommitment === 'string') {
                    commitment = configOrCommitment;
                }
                else {
                    commitment = configOrCommitment.commitment;
                    if (configOrCommitment.dataSlice) {
                        extra.dataSlice = configOrCommitment.dataSlice;
                    }
                    if (configOrCommitment.filters) {
                        extra.filters = configOrCommitment.filters;
                    }
                }
            }
            const args = connection._buildArgs([this.PUBKEY.toBase58()], commitment, 'base64', extra);
            const unsafeRes = yield connection._rpcRequest('getProgramAccounts', args);
            return unsafeRes.result
                .map(({ account: { data, executable, lamports, owner }, pubkey }) => ({
                account: {
                    data: Buffer$1.from(data[0], 'base64'),
                    executable,
                    lamports,
                    owner: new PublicKey(owner),
                },
                pubkey: new PublicKey(pubkey),
            }))
                .map(({ pubkey, account }) => new Account(pubkey, account));
        });
    }
}

class AuctionProgram extends Program {
}
AuctionProgram.PREFIX = 'auction';
AuctionProgram.EXTENDED = 'extended';
AuctionProgram.PUBKEY = new PublicKey(config.programs.auction);

var _a$D;
class BidderMetadataData extends Data {
}
_a$D = BidderMetadataData;
BidderMetadataData.SCHEMA = _a$D.struct([
    ['bidderPubkey', 'pubkeyAsString'],
    ['auctionPubkey', 'pubkeyAsString'],
    ['lastBid', 'u64'],
    ['lastBidTimestamp', 'u64'],
    ['cancelled', 'u8'],
]);
class BidderMetadata extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!BidderMetadata.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = BidderMetadataData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === BidderMetadata.DATA_SIZE;
    }
}
BidderMetadata.DATA_SIZE = 32 + 32 + 8 + 8 + 1;

var _a$C;
class BidderPotData extends Data {
}
_a$C = BidderPotData;
BidderPotData.SCHEMA = _a$C.struct([
    ['bidderPot', 'pubkeyAsString'],
    ['bidderAct', 'pubkeyAsString'],
    ['auctionAct', 'pubkeyAsString'],
    ['emptied', 'u8'],
]);
class BidderPot extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!BidderPot.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = BidderPotData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === BidderPot.DATA_SIZE;
    }
}
BidderPot.DATA_SIZE = 32 + 32 + 32 + 1;

var _a$B, _b$7, _c$2, _d;
var AuctionState;
(function (AuctionState) {
    AuctionState[AuctionState["Created"] = 0] = "Created";
    AuctionState[AuctionState["Started"] = 1] = "Started";
    AuctionState[AuctionState["Ended"] = 2] = "Ended";
})(AuctionState || (AuctionState = {}));
var BidStateType;
(function (BidStateType) {
    BidStateType[BidStateType["EnglishAuction"] = 0] = "EnglishAuction";
    BidStateType[BidStateType["OpenEdition"] = 1] = "OpenEdition";
})(BidStateType || (BidStateType = {}));
var PriceFloorType;
(function (PriceFloorType) {
    PriceFloorType[PriceFloorType["None"] = 0] = "None";
    PriceFloorType[PriceFloorType["Minimum"] = 1] = "Minimum";
    PriceFloorType[PriceFloorType["BlindedPrice"] = 2] = "BlindedPrice";
})(PriceFloorType || (PriceFloorType = {}));
class Bid extends Data {
}
_a$B = Bid;
Bid.SCHEMA = _a$B.struct([
    ['key', 'pubkeyAsString'],
    ['amount', 'u64'],
]);
class BidState extends Data {
    getWinnerAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].key;
        }
        else {
            return null;
        }
    }
    getAmountAt(winnerIndex) {
        const convertedIndex = this.bids.length - winnerIndex - 1;
        if (convertedIndex >= 0 && convertedIndex < this.bids.length) {
            return this.bids[convertedIndex].amount;
        }
        else {
            return null;
        }
    }
    getWinnerIndex(bidder) {
        if (!this.bids)
            return null;
        const index = this.bids.findIndex((b) => b.key === bidder);
        if (index !== -1) {
            const zeroBased = this.bids.length - index - 1;
            return zeroBased < this.max.toNumber() ? zeroBased : null;
        }
        else
            return null;
    }
}
_b$7 = BidState;
BidState.SCHEMA = new Map([
    ...Bid.SCHEMA,
    ..._b$7.struct([
        ['type', 'u8'],
        ['bids', [Bid]],
        ['max', 'u64'],
    ]),
]);
class PriceFloor extends Data {
    constructor(args) {
        super();
        this.type = args.type;
        this.hash = args.hash || new Uint8Array(32);
        if (this.type === PriceFloorType.Minimum) {
            if (args.minPrice) {
                this.hash.set(args.minPrice.toArrayLike(Buffer$1, 'le', 8), 0);
            }
            else {
                this.minPrice = new BN((args.hash || new Uint8Array(0)).slice(0, 8), 'le');
            }
        }
    }
}
_c$2 = PriceFloor;
PriceFloor.SCHEMA = _c$2.struct([
    ['type', 'u8'],
    ['hash', [32]],
]);
class AuctionData extends Data {
}
_d = AuctionData;
AuctionData.SCHEMA = new Map([
    ...BidState.SCHEMA,
    ...PriceFloor.SCHEMA,
    ..._d.struct([
        ['authority', 'pubkeyAsString'],
        ['tokenMint', 'pubkeyAsString'],
        ['lastBid', { kind: 'option', type: 'u64' }],
        ['endedAt', { kind: 'option', type: 'u64' }],
        ['endAuctionAt', { kind: 'option', type: 'u64' }],
        ['auctionGap', { kind: 'option', type: 'u64' }],
        ['priceFloor', PriceFloor],
        ['state', 'u8'],
        ['bidState', BidState],
    ]),
]);
class Auction extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        this.data = AuctionData.deserialize(this.info.data);
    }
    static getPDA(vault) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(vault).toBuffer(),
        ]);
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    filters.authority && {
                        memcmp: {
                            offset: 0,
                            bytes: new PublicKey(filters.authority).toBase58(),
                        },
                    },
                ].filter(Boolean),
            }))
                .map((account) => {
                try {
                    return Auction.from(account);
                }
                catch (err) { }
            })
                .filter(Boolean);
        });
    }
    getBidderPots(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        dataSize: BidderPot.DATA_SIZE,
                    },
                    {
                        memcmp: {
                            offset: 32 + 32,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidderPot.from(account));
        });
    }
    getBidderMetadata(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield AuctionProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        dataSize: BidderMetadata.DATA_SIZE,
                    },
                    {
                        memcmp: {
                            offset: 32,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidderMetadata.from(account));
        });
    }
}
Auction.EXTENDED_DATA_SIZE = 8 + 9 + 2 + 200;

var _a$A;
class AuctionDataExtended extends Data {
}
_a$A = AuctionDataExtended;
AuctionDataExtended.SCHEMA = _a$A.struct([
    ['totalUncancelledBids', 'u64'],
    ['tickSize', { kind: 'option', type: 'u64' }],
    ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
]);
class AuctionExtended extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(AuctionProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!AuctionExtended.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = AuctionDataExtended.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data.length === AuctionExtended.DATA_SIZE;
    }
    static getPDA(vault) {
        return AuctionProgram.findProgramAddress([
            Buffer$1.from(AuctionProgram.PREFIX),
            AuctionProgram.PUBKEY.toBuffer(),
            new PublicKey(vault).toBuffer(),
            Buffer$1.from(AuctionProgram.EXTENDED),
        ]);
    }
}
AuctionExtended.DATA_SIZE = 8 + 9 + 2 + 200;

var _a$z;
class CancelBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 0;
    }
}
_a$z = CancelBidArgs;
CancelBidArgs.SCHEMA = _a$z.struct([
    ['instruction', 'u8'],
    ['resource', 'pubkeyAsString'],
]);
class CancelBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { auction, auctionExtended, bidderPot, bidderMeta, bidder, bidderToken, bidderPotToken, tokenMint, resource, } = params;
        const data = CancelBidArgs.serialize({ resource: resource.toString() });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: bidder,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: bidderToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderMeta,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$y, _b$6;
var WinnerLimitType;
(function (WinnerLimitType) {
    WinnerLimitType[WinnerLimitType["Unlimited"] = 0] = "Unlimited";
    WinnerLimitType[WinnerLimitType["Capped"] = 1] = "Capped";
})(WinnerLimitType || (WinnerLimitType = {}));
class WinnerLimit extends Data {
}
_a$y = WinnerLimit;
WinnerLimit.SCHEMA = _a$y.struct([
    ['type', 'u8'],
    ['usize', 'u64'],
]);
class CreateAuctionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 1;
    }
}
_b$6 = CreateAuctionArgs;
CreateAuctionArgs.SCHEMA = new Map([
    ...WinnerLimit.SCHEMA,
    ...PriceFloor.SCHEMA,
    ..._b$6.struct([
        ['instruction', 'u8'],
        ['winners', WinnerLimit],
        ['endAuctionAt', { kind: 'option', type: 'u64' }],
        ['auctionGap', { kind: 'option', type: 'u64' }],
        ['tokenMint', 'pubkeyAsString'],
        ['authority', 'pubkeyAsString'],
        ['resource', 'pubkeyAsString'],
        ['priceFloor', PriceFloor],
        ['tickSize', { kind: 'option', type: 'u64' }],
        ['gapTickSizePercentage', { kind: 'option', type: 'u8' }],
    ]),
]);
class CreateAuction extends Transaction {
    constructor(options, params) {
        super(options);
        const { args, auction, auctionExtended, creator } = params;
        const data = CreateAuctionArgs.serialize(args);
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: creator,
                    isSigner: true,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$x;
class PlaceBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 6;
    }
}
_a$x = PlaceBidArgs;
PlaceBidArgs.SCHEMA = _a$x.struct([
    ['instruction', 'u8'],
    ['amount', 'u64'],
    ['resource', 'pubkeyAsString'],
]);
class PlaceBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { auction, auctionExtended, bidderPot, bidderMeta, bidder, bidderToken, bidderPotToken, tokenMint, transferAuthority, resource, amount, } = params;
        const data = PlaceBidArgs.serialize({ resource: resource.toString(), amount });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: bidder,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: bidderToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderMeta,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionExtended,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var _a$w;
class SetAuctionAuthorityArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 5;
    }
}
_a$w = SetAuctionAuthorityArgs;
SetAuctionAuthorityArgs.SCHEMA = _a$w.struct([['instruction', 'u8']]);
class SetAuctionAuthority extends Transaction {
    constructor(options, params) {
        super(options);
        const { auction, currentAuthority, newAuthority } = params;
        const data = SetAuctionAuthorityArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: currentAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: newAuthority,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: AuctionProgram.PUBKEY,
            data,
        }));
    }
}

var MetadataKey;
(function (MetadataKey) {
    MetadataKey[MetadataKey["Uninitialized"] = 0] = "Uninitialized";
    MetadataKey[MetadataKey["MetadataV1"] = 4] = "MetadataV1";
    MetadataKey[MetadataKey["EditionV1"] = 1] = "EditionV1";
    MetadataKey[MetadataKey["MasterEditionV1"] = 2] = "MasterEditionV1";
    MetadataKey[MetadataKey["MasterEditionV2"] = 6] = "MasterEditionV2";
    MetadataKey[MetadataKey["EditionMarker"] = 7] = "EditionMarker";
})(MetadataKey || (MetadataKey = {}));
class MetadataProgram extends Program {
}
MetadataProgram.PREFIX = 'metadata';
MetadataProgram.PUBKEY = new PublicKey(config.programs.metadata);

var _a$v;
class EditionData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.EditionV1;
    }
}
_a$v = EditionData;
EditionData.SCHEMA = _a$v.struct([
    ['key', 'u8'],
    ['parent', 'pubkeyAsString'],
    ['edition', 'u64'],
]);
class Edition extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Edition.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = EditionData.deserialize(this.info.data);
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(Edition.EDITION_PREFIX),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.EditionV1;
    }
}
Edition.EDITION_PREFIX = 'edition';

var _a$u;
class EditionMarkerData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.EditionMarker;
    }
    editionTaken(edition) {
        const editionOffset = edition % EditionMarker.DATA_SIZE;
        const indexOffset = Math.floor(editionOffset / 8);
        if (indexOffset > 30) {
            throw Error('Bad index for edition');
        }
        const positionInBitsetFromRight = 7 - (editionOffset % 8);
        const mask = Math.pow(2, positionInBitsetFromRight);
        const appliedMask = this.ledger[indexOffset] & mask;
        return appliedMask != 0;
    }
}
_a$u = EditionMarkerData;
EditionMarkerData.SCHEMA = _a$u.struct([
    ['key', 'u8'],
    ['ledger', [31]],
]);
class EditionMarker extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!EditionMarker.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = EditionMarkerData.deserialize(this.info.data);
    }
    static getPDA(mint, edition) {
        return __awaiter(this, void 0, void 0, function* () {
            const editionNumber = Math.floor(edition.toNumber() / 248);
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(Edition.EDITION_PREFIX),
                Buffer$1.from(editionNumber.toString()),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.EditionMarker;
    }
}
EditionMarker.DATA_SIZE = 248;

var _a$t, _b$5;
class MasterEditionV1Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MasterEditionV1;
    }
}
_a$t = MasterEditionV1Data;
MasterEditionV1Data.SCHEMA = _a$t.struct([
    ['key', 'u8'],
    ['supply', 'u64'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
    ['printingMint', 'pubkeyAsString'],
    ['oneTimePrintingAuthorizationMint', 'pubkeyAsString'],
]);
class MasterEditionV2Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MasterEditionV2;
    }
}
_b$5 = MasterEditionV2Data;
MasterEditionV2Data.SCHEMA = _b$5.struct([
    ['key', 'u8'],
    ['supply', 'u64'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
]);
class MasterEdition extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (MasterEdition.isMasterEditionV1(this.info.data)) {
            this.data = MasterEditionV1Data.deserialize(this.info.data);
        }
        else if (MasterEdition.isMasterEditionV2(this.info.data)) {
            this.data = MasterEditionV2Data.deserialize(this.info.data);
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
                Buffer$1.from(MasterEdition.EDITION_PREFIX),
            ]);
        });
    }
    static isCompatible(data) {
        return MasterEdition.isMasterEditionV1(data) || MasterEdition.isMasterEditionV2(data);
    }
    static isMasterEditionV1(data) {
        return data[0] === MetadataKey.MasterEditionV1;
    }
    static isMasterEditionV2(data) {
        return data[0] === MetadataKey.MasterEditionV2;
    }
    getEditions(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetadataProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetadataKey.EditionV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => Edition.from(account));
        });
    }
}
MasterEdition.EDITION_PREFIX = 'edition';

class TokenAccount extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(TOKEN_PROGRAM_ID)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!TokenAccount.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize$2(this.info.data);
    }
    static isCompatible(data) {
        return data.length === AccountLayout.span;
    }
    static getTokenAccountsByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield connection.getTokenAccountsByOwner(new PublicKey(owner), {
                programId: TOKEN_PROGRAM_ID,
            })).value.map(({ pubkey, account }) => new TokenAccount(pubkey, account));
        });
    }
}
const deserialize$2 = (data) => {
    const accountInfo = AccountLayout.decode(data);
    accountInfo.mint = new PublicKey(accountInfo.mint);
    accountInfo.owner = new PublicKey(accountInfo.owner);
    accountInfo.amount = u64.fromBuffer(accountInfo.amount);
    if (accountInfo.delegateOption === 0) {
        accountInfo.delegate = null;
        accountInfo.delegatedAmount = new u64(0);
    }
    else {
        accountInfo.delegate = new PublicKey(accountInfo.delegate);
        accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);
    }
    accountInfo.isInitialized = accountInfo.state !== 0;
    accountInfo.isFrozen = accountInfo.state === 2;
    if (accountInfo.isNativeOption === 1) {
        accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);
        accountInfo.isNative = true;
    }
    else {
        accountInfo.rentExemptReserve = null;
        accountInfo.isNative = false;
    }
    if (accountInfo.closeAuthorityOption === 0) {
        accountInfo.closeAuthority = null;
    }
    else {
        accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);
    }
    return accountInfo;
};

class PayForFiles extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { lamports, fileHashes, arweaveWallet } = params;
        super(options);
        this.add(SystemProgram.transfer({
            fromPubkey: feePayer,
            toPubkey: arweaveWallet !== null && arweaveWallet !== void 0 ? arweaveWallet : new PublicKey(config.arweaveWallet),
            lamports,
        }));
        fileHashes.forEach((data) => {
            this.add(new TransactionInstruction({
                keys: [],
                programId: new PublicKey(config.programs.memo),
                data,
            }));
        });
    }
}

class CreateMint extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { newAccountPubkey, lamports, decimals, owner, freezeAuthority } = params;
        super(options);
        this.add(SystemProgram.createAccount({
            fromPubkey: feePayer,
            newAccountPubkey,
            lamports,
            space: MintLayout.span,
            programId: TOKEN_PROGRAM_ID,
        }));
        this.add(Token.createInitMintInstruction(TOKEN_PROGRAM_ID, newAccountPubkey, decimals !== null && decimals !== void 0 ? decimals : 0, owner !== null && owner !== void 0 ? owner : feePayer, freezeAuthority !== null && freezeAuthority !== void 0 ? freezeAuthority : feePayer));
    }
}

class CreateTokenAccount extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { newAccountPubkey, lamports, mint, owner } = params;
        super(options);
        this.add(SystemProgram.createAccount({
            fromPubkey: feePayer,
            newAccountPubkey,
            lamports,
            space: AccountLayout.span,
            programId: TOKEN_PROGRAM_ID,
        }));
        this.add(Token.createInitAccountInstruction(TOKEN_PROGRAM_ID, mint, newAccountPubkey, owner !== null && owner !== void 0 ? owner : feePayer));
    }
}

class CreateAssociatedTokenAccount extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { associatedTokenAddress, walletAddress, splTokenMintAddress } = params;
        super(options);
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: true,
                },
                {
                    pubkey: associatedTokenAddress,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: walletAddress !== null && walletAddress !== void 0 ? walletAddress : feePayer,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: splTokenMintAddress,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: ASSOCIATED_TOKEN_PROGRAM_ID,
            data: Buffer$1.from([]),
        }));
    }
}

class MintTo extends Transaction {
    constructor(options, params) {
        const { feePayer } = options;
        const { mint, dest, authority, amount } = params;
        super(options);
        this.add(Token.createMintToInstruction(TOKEN_PROGRAM_ID, mint, dest, authority !== null && authority !== void 0 ? authority : feePayer, [], new BN(amount).toNumber()));
    }
}

var _a$s, _b$4, _c$1;
class Creator extends Data {
}
_a$s = Creator;
Creator.SCHEMA = _a$s.struct([
    ['address', 'pubkeyAsString'],
    ['verified', 'u8'],
    ['share', 'u8'],
]);
class MetadataDataData extends Data {
    constructor(args) {
        super(args);
        const METADATA_REPLACE = new RegExp('\u0000', 'g');
        this.name = args.name.replace(METADATA_REPLACE, '');
        this.uri = args.uri.replace(METADATA_REPLACE, '');
        this.symbol = args.symbol.replace(METADATA_REPLACE, '');
    }
}
_b$4 = MetadataDataData;
MetadataDataData.SCHEMA = new Map([
    ...Creator.SCHEMA,
    ..._b$4.struct([
        ['name', 'string'],
        ['symbol', 'string'],
        ['uri', 'string'],
        ['sellerFeeBasisPoints', 'u16'],
        ['creators', { kind: 'option', type: [Creator] }],
    ]),
]);
class MetadataData extends Data {
    constructor(args) {
        super(args);
        this.key = MetadataKey.MetadataV1;
    }
}
_c$1 = MetadataData;
MetadataData.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._c$1.struct([
        ['key', 'u8'],
        ['updateAuthority', 'pubkeyAsString'],
        ['mint', 'pubkeyAsString'],
        ['data', MetadataDataData],
        ['primarySaleHappened', 'u8'],
        ['isMutable', 'u8'],
    ]),
]);
class Metadata extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetadataProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Metadata.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = MetadataData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetadataKey.MetadataV1;
    }
    static getPDA(mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetadataProgram.findProgramAddress([
                Buffer$1.from(MetadataProgram.PREFIX),
                MetadataProgram.PUBKEY.toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const baseFilters = [
                {
                    memcmp: {
                        offset: 0,
                        bytes: bs58.encode(Buffer$1.from([MetadataKey.MetadataV1])),
                    },
                },
                filters.updateAuthority && {
                    memcmp: {
                        offset: 1,
                        bytes: new PublicKey(filters.updateAuthority).toBase58(),
                    },
                },
                filters.mint && {
                    memcmp: {
                        offset: 33,
                        bytes: new PublicKey(filters.mint).toBase58(),
                    },
                },
            ].filter(Boolean);
            if (filters.creators) {
                return (yield Promise.all(Array.from(Array(config.maxCreatorLimit).keys()).reduce((prev, i) => [
                    ...prev,
                    ...filters.creators.map((pubkey) => MetadataProgram.getProgramAccounts(connection, {
                        filters: [
                            ...baseFilters,
                            {
                                memcmp: {
                                    offset: computeCreatorOffset(i),
                                    bytes: new PublicKey(pubkey).toBase58(),
                                },
                            },
                        ],
                    })),
                ], [])))
                    .flat()
                    .map((account) => Metadata.from(account));
            }
            else {
                return (yield MetadataProgram.getProgramAccounts(connection, { filters: baseFilters })).map((account) => Metadata.from(account));
            }
        });
    }
    static findByOwner(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield TokenAccount.getTokenAccountsByOwner(connection, owner);
            const accountMap = new Map(accounts.map(({ data }) => [data.mint.toString(), data]));
            const allMetadata = yield Metadata.findMany(connection);
            return allMetadata.filter((metadata) => {
                var _d, _e;
                return accountMap.has(metadata.data.mint) &&
                    (((_e = (_d = accountMap === null || accountMap === void 0 ? void 0 : accountMap.get(metadata.data.mint)) === null || _d === void 0 ? void 0 : _d.amount) === null || _e === void 0 ? void 0 : _e.toNumber()) || 0) > 0;
            });
        });
    }
    static findByOwnerV2(connection, owner) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield TokenAccount.getTokenAccountsByOwner(connection, owner);
            const accountsWithAmount = accounts
                .map(({ data }) => data)
                .filter(({ amount }) => (amount === null || amount === void 0 ? void 0 : amount.toNumber()) > 0);
            return (yield Promise.all(accountsWithAmount.map(({ mint }) => Metadata.findMany(connection, { mint })))).flat();
        });
    }
    getEdition(connection) {
        var _d;
        return __awaiter(this, void 0, void 0, function* () {
            const mint = (_d = this.data) === null || _d === void 0 ? void 0 : _d.mint;
            if (!mint)
                return;
            const pda = yield Edition.getPDA(mint);
            const info = yield Account.getInfo(connection, pda);
            const key = info === null || info === void 0 ? void 0 : info.data[0];
            switch (key) {
                case MetadataKey.EditionV1:
                    return new Edition(pda, info);
                case MetadataKey.MasterEditionV1:
                case MetadataKey.MasterEditionV2:
                    return new MasterEdition(pda, info);
                default:
                    return;
            }
        });
    }
}
const MAX_NAME_LENGTH = 32;
const MAX_SYMBOL_LENGTH = 10;
const MAX_URI_LENGTH = 200;
const MAX_CREATOR_LEN = 32 + 1 + 1;
const computeCreatorOffset = (index) => {
    return (1 +
        32 +
        32 +
        4 +
        MAX_NAME_LENGTH +
        4 +
        MAX_URI_LENGTH +
        4 +
        MAX_SYMBOL_LENGTH +
        2 +
        1 +
        4 +
        index * MAX_CREATOR_LEN);
};

var _a$r;
class CreateMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 0;
    }
}
_a$r = CreateMetadataArgs;
CreateMetadataArgs.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._a$r.struct([
        ['instruction', 'u8'],
        ['data', MetadataDataData],
        ['isMutable', 'u8'],
    ]),
]);
class CreateMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { metadata, metadataData, updateAuthority, mint, mintAuthority } = params;
        const data = CreateMetadataArgs.serialize({
            data: metadataData,
            isMutable: true,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$q;
class UpdateMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 1;
        this.data = null;
        this.updateAuthority = null;
    }
}
_a$q = UpdateMetadataArgs;
UpdateMetadataArgs.SCHEMA = new Map([
    ...MetadataDataData.SCHEMA,
    ..._a$q.struct([
        ['instruction', 'u8'],
        ['data', { kind: 'option', type: MetadataDataData }],
        ['updateAuthority', { kind: 'option', type: 'pubkeyAsString' }],
        ['primarySaleHappened', { kind: 'option', type: 'u8' }],
    ]),
]);
class UpdateMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, metadataData, updateAuthority, newUpdateAuthority, primarySaleHappened } = params;
        const data = UpdateMetadataArgs.serialize({
            data: metadataData,
            updateAuthority: newUpdateAuthority && newUpdateAuthority.toString(),
            primarySaleHappened: primarySaleHappened || null,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: true,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$p;
class CreateMasterEditionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 10;
    }
}
_a$p = CreateMasterEditionArgs;
CreateMasterEditionArgs.SCHEMA = _a$p.struct([
    ['instruction', 'u8'],
    ['maxSupply', { kind: 'option', type: 'u64' }],
]);
class CreateMasterEdition extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, mint, mintAuthority, maxSupply } = params;
        const data = CreateMasterEditionArgs.serialize({
            maxSupply: maxSupply || null,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: edition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$o;
class MintNewEditionFromMasterEditionViaTokenArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 11;
    }
}
_a$o = MintNewEditionFromMasterEditionViaTokenArgs;
MintNewEditionFromMasterEditionViaTokenArgs.SCHEMA = _a$o.struct([
    ['instruction', 'u8'],
    ['edition', 'u64'],
]);
class MintNewEditionFromMasterEditionViaToken extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { edition, metadata, updateAuthority, masterEdition, masterMetadata, mint, editionMarker, mintAuthority, tokenOwner, tokenAccount, editionValue, } = params;
        const data = MintNewEditionFromMasterEditionViaTokenArgs.serialize({
            edition: editionValue,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: edition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: masterEdition,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: editionMarker,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: mintAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenOwner,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: updateAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: masterMetadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$n;
class UpdatePrimarySaleHappenedViaTokenArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 4;
    }
}
_a$n = UpdatePrimarySaleHappenedViaTokenArgs;
UpdatePrimarySaleHappenedViaTokenArgs.SCHEMA = _a$n.struct([['instruction', 'u8']]);
class UpdatePrimarySaleHappenedViaToken extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, owner, tokenAccount } = params;
        const data = UpdatePrimarySaleHappenedViaTokenArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: owner,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var _a$m;
class SignMetadataArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 7;
    }
}
_a$m = SignMetadataArgs;
SignMetadataArgs.SCHEMA = _a$m.struct([['instruction', 'u8']]);
class SignMetadata extends Transaction {
    constructor(options, params) {
        super(options);
        const { metadata, creator } = params;
        const data = SignMetadataArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: metadata,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: creator,
                    isSigner: true,
                    isWritable: false,
                },
            ],
            programId: MetadataProgram.PUBKEY,
            data,
        }));
    }
}

var MetaplexKey;
(function (MetaplexKey) {
    MetaplexKey[MetaplexKey["Uninitialized"] = 0] = "Uninitialized";
    MetaplexKey[MetaplexKey["OriginalAuthorityLookupV1"] = 1] = "OriginalAuthorityLookupV1";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV1"] = 2] = "BidRedemptionTicketV1";
    MetaplexKey[MetaplexKey["StoreV1"] = 3] = "StoreV1";
    MetaplexKey[MetaplexKey["WhitelistedCreatorV1"] = 4] = "WhitelistedCreatorV1";
    MetaplexKey[MetaplexKey["PayoutTicketV1"] = 5] = "PayoutTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositValidationTicketV1"] = 6] = "SafetyDepositValidationTicketV1";
    MetaplexKey[MetaplexKey["AuctionManagerV1"] = 7] = "AuctionManagerV1";
    MetaplexKey[MetaplexKey["PrizeTrackingTicketV1"] = 8] = "PrizeTrackingTicketV1";
    MetaplexKey[MetaplexKey["SafetyDepositConfigV1"] = 9] = "SafetyDepositConfigV1";
    MetaplexKey[MetaplexKey["AuctionManagerV2"] = 10] = "AuctionManagerV2";
    MetaplexKey[MetaplexKey["BidRedemptionTicketV2"] = 11] = "BidRedemptionTicketV2";
    MetaplexKey[MetaplexKey["AuctionWinnerTokenTypeTrackerV1"] = 12] = "AuctionWinnerTokenTypeTrackerV1";
})(MetaplexKey || (MetaplexKey = {}));
class MetaplexProgram extends Program {
}
MetaplexProgram.PREFIX = 'metaplex';
MetaplexProgram.TOTALS = 'totals';
MetaplexProgram.PUBKEY = new PublicKey(config.programs.metaplex);

const WINNER_INDEX_OFFSETS = [2, 10];
class BidRedemptionTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (BidRedemptionTicket.isBidRedemptionTicketV1(this.info.data)) {
            throw ERROR_DEPRECATED_ACCOUNT_DATA();
        }
        else if (BidRedemptionTicket.isBidRedemptionTicketV2(this.info.data)) {
            const data = this.info.data.toJSON().data;
            const winnerIndex = data[1] !== 0 && new BN(data.slice(1, 9), 'le');
            const offset = WINNER_INDEX_OFFSETS[+!!winnerIndex];
            this.data = {
                key: MetaplexKey.BidRedemptionTicketV2,
                winnerIndex,
                data,
                auctionManager: bs58.encode(data.slice(offset, offset + 32)),
            };
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static isCompatible(data) {
        return (BidRedemptionTicket.isBidRedemptionTicketV1(data) ||
            BidRedemptionTicket.isBidRedemptionTicketV2(data));
    }
    static isBidRedemptionTicketV1(data) {
        return data[0] === MetaplexKey.BidRedemptionTicketV1;
    }
    static isBidRedemptionTicketV2(data) {
        return data[0] === MetaplexKey.BidRedemptionTicketV2;
    }
}

var _a$l, _b$3;
var AuctionManagerStatus;
(function (AuctionManagerStatus) {
    AuctionManagerStatus[AuctionManagerStatus["Initialized"] = 0] = "Initialized";
    AuctionManagerStatus[AuctionManagerStatus["Validated"] = 1] = "Validated";
    AuctionManagerStatus[AuctionManagerStatus["Running"] = 2] = "Running";
    AuctionManagerStatus[AuctionManagerStatus["Disbursing"] = 3] = "Disbursing";
    AuctionManagerStatus[AuctionManagerStatus["Finished"] = 4] = "Finished";
})(AuctionManagerStatus || (AuctionManagerStatus = {}));
class AuctionManagerStateV2 extends Data {
    constructor() {
        super(...arguments);
        this.status = AuctionManagerStatus.Initialized;
        this.safetyConfigItemsValidated = new BN(0);
        this.bidsPushedToAcceptPayment = new BN(0);
        this.hasParticipation = false;
    }
}
_a$l = AuctionManagerStateV2;
AuctionManagerStateV2.SCHEMA = _a$l.struct([
    ['status', 'u8'],
    ['safetyConfigItemsValidated', 'u64'],
    ['bidsPushedToAcceptPayment', 'u64'],
    ['hasParticipation', 'u8'],
]);
class AuctionManagerV2Data extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.AuctionManagerV2;
    }
}
_b$3 = AuctionManagerV2Data;
AuctionManagerV2Data.SCHEMA = new Map([
    ...AuctionManagerStateV2.SCHEMA,
    ..._b$3.struct([
        ['key', 'u8'],
        ['store', 'pubkeyAsString'],
        ['authority', 'pubkeyAsString'],
        ['auction', 'pubkeyAsString'],
        ['vault', 'pubkeyAsString'],
        ['acceptPayment', 'pubkeyAsString'],
        ['state', AuctionManagerStateV2],
    ]),
]);
class AuctionManager extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (AuctionManager.isAuctionManagerV1(this.info.data)) {
            throw ERROR_DEPRECATED_ACCOUNT_DATA();
        }
        else if (AuctionManager.isAuctionManagerV2(this.info.data)) {
            this.data = AuctionManagerV2Data.deserialize(this.info.data);
        }
        else {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
    }
    static isCompatible(data) {
        return AuctionManager.isAuctionManagerV1(data) || AuctionManager.isAuctionManagerV2(data);
    }
    static isAuctionManagerV1(data) {
        return data[0] === MetaplexKey.AuctionManagerV1;
    }
    static isAuctionManagerV2(data) {
        return data[0] === MetaplexKey.AuctionManagerV2;
    }
    static getPDA(auction) {
        return MetaplexProgram.findProgramAddress([
            Buffer$1.from(MetaplexProgram.PREFIX),
            new PublicKey(auction).toBuffer(),
        ]);
    }
    static findMany(connection, filters = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.AuctionManagerV2])),
                        },
                    },
                    filters.store && {
                        memcmp: {
                            offset: 1,
                            bytes: new PublicKey(filters.store).toBase58(),
                        },
                    },
                    filters.authority && {
                        memcmp: {
                            offset: 33,
                            bytes: new PublicKey(filters.authority).toBase58(),
                        },
                    },
                ].filter(Boolean),
            })).map((account) => AuctionManager.from(account));
        });
    }
    getAuction(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return Auction.load(connection, this.data.auction);
        });
    }
    getBidRedemptionTickets(connection, haveWinnerIndex = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.BidRedemptionTicketV2])),
                        },
                    },
                    {
                        memcmp: {
                            offset: WINNER_INDEX_OFFSETS[+haveWinnerIndex],
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => BidRedemptionTicket.from(account));
        });
    }
}

var _a$k;
class PayoutTicketData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.PayoutTicketV1;
    }
}
_a$k = PayoutTicketData;
PayoutTicketData.SCHEMA = _a$k.struct([
    ['key', 'u8'],
    ['recipient', 'pubkeyAsString'],
    ['amountPaid', 'u64'],
]);
class PayoutTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PayoutTicket.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PayoutTicketData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.PayoutTicketV1;
    }
    static getPayoutTicketsByRecipient(connection, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.PayoutTicketV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: new PublicKey(recipient).toBase58(),
                        },
                    },
                ],
            })).map((account) => PayoutTicket.from(account));
        });
    }
}

var _a$j;
class PrizeTrackingTicketData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.PrizeTrackingTicketV1;
        this.key = MetaplexKey.PrizeTrackingTicketV1;
    }
}
_a$j = PrizeTrackingTicketData;
PrizeTrackingTicketData.SCHEMA = _a$j.struct([
    ['key', 'u8'],
    ['metadata', 'pubkeyAsString'],
    ['supplySnapshot', 'u64'],
    ['expectedRedemptions', 'u64'],
    ['redemptions', 'u64'],
]);
class PrizeTrackingTicket extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PrizeTrackingTicket.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PrizeTrackingTicketData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.PrizeTrackingTicketV1;
    }
    static getPDA(auctionManager, mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
}

var WinningConfigType;
(function (WinningConfigType) {
    WinningConfigType[WinningConfigType["TokenOnlyTransfer"] = 0] = "TokenOnlyTransfer";
    WinningConfigType[WinningConfigType["FullRightsTransfer"] = 1] = "FullRightsTransfer";
    WinningConfigType[WinningConfigType["PrintingV1"] = 2] = "PrintingV1";
    WinningConfigType[WinningConfigType["PrintingV2"] = 3] = "PrintingV2";
    WinningConfigType[WinningConfigType["Participation"] = 4] = "Participation";
})(WinningConfigType || (WinningConfigType = {}));
var WinningConstraint;
(function (WinningConstraint) {
    WinningConstraint[WinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    WinningConstraint[WinningConstraint["ParticipationPrizeGiven"] = 1] = "ParticipationPrizeGiven";
})(WinningConstraint || (WinningConstraint = {}));
var NonWinningConstraint;
(function (NonWinningConstraint) {
    NonWinningConstraint[NonWinningConstraint["NoParticipationPrize"] = 0] = "NoParticipationPrize";
    NonWinningConstraint[NonWinningConstraint["GivenForFixedPrice"] = 1] = "GivenForFixedPrice";
    NonWinningConstraint[NonWinningConstraint["GivenForBidPrice"] = 2] = "GivenForBidPrice";
})(NonWinningConstraint || (NonWinningConstraint = {}));
class SafetyDepositConfig extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!SafetyDepositConfig.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize$1(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.SafetyDepositConfigV1;
    }
    static getPDA(auctionManager, safetyDeposit) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                new PublicKey(safetyDeposit).toBuffer(),
            ]);
        });
    }
}
const deserialize$1 = (buffer) => {
    const data = {
        key: MetaplexKey.SafetyDepositConfigV1,
        auctionManager: bs58.encode(buffer.slice(1, 33)),
        order: new BN(buffer.slice(33, 41), 'le'),
        winningConfigType: buffer[41],
        amountType: buffer[42],
        lengthType: buffer[43],
        amountRanges: [],
        participationConfig: null,
        participationState: null,
    };
    const lengthOfArray = new BN(buffer.slice(44, 48), 'le');
    let offset = 48;
    for (let i = 0; i < lengthOfArray.toNumber(); i++) {
        const amount = getBNFromData(buffer, offset, data.amountType);
        offset += data.amountType;
        const length = getBNFromData(buffer, offset, data.lengthType);
        offset += data.lengthType;
        data.amountRanges.push({ amount, length });
    }
    if (buffer[offset] == 0) {
        offset += 1;
        data.participationConfig = null;
    }
    else {
        const winnerConstraint = buffer[offset + 1];
        const nonWinningConstraint = buffer[offset + 2];
        let fixedPrice = null;
        offset += 3;
        if (buffer[offset] == 1) {
            fixedPrice = new BN(buffer.slice(offset + 1, offset + 9), 'le');
            offset += 9;
        }
        else {
            offset += 1;
        }
        data.participationConfig = {
            winnerConstraint,
            nonWinningConstraint,
            fixedPrice,
        };
    }
    if (buffer[offset] == 0) {
        offset += 1;
        data.participationState = null;
    }
    else {
        const collectedToAcceptPayment = new BN(buffer.slice(offset + 1, offset + 9), 'le');
        offset += 9;
        data.participationState = {
            collectedToAcceptPayment,
        };
    }
    return data;
};

var _a$i;
class WhitelistedCreatorData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.WhitelistedCreatorV1;
        this.activated = true;
        this.key = MetaplexKey.WhitelistedCreatorV1;
    }
}
_a$i = WhitelistedCreatorData;
WhitelistedCreatorData.SCHEMA = _a$i.struct([
    ['key', 'u8'],
    ['address', 'pubkeyAsString'],
    ['activated', 'u8'],
]);
class WhitelistedCreator extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!WhitelistedCreator.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = WhitelistedCreatorData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.WhitelistedCreatorV1;
    }
    static getPDA(store, creator) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(store).toBuffer(),
                new PublicKey(creator).toBuffer(),
            ]);
        });
    }
}

var _a$h;
class StoreData extends Data {
    constructor(args) {
        super(args);
        this.key = MetaplexKey.StoreV1;
        this.public = true;
        this.key = MetaplexKey.StoreV1;
    }
}
_a$h = StoreData;
StoreData.SCHEMA = _a$h.struct([
    ['key', 'u8'],
    ['public', 'u8'],
    ['auctionProgram', 'pubkeyAsString'],
    ['tokenVaultProgram', 'pubkeyAsString'],
    ['tokenMetadataProgram', 'pubkeyAsString'],
    ['tokenProgram', 'pubkeyAsString'],
]);
class Store extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Store.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = StoreData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.StoreV1;
    }
    static getPDA(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(owner).toBuffer(),
            ]);
        });
    }
    getWhitelistedCreators(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.WhitelistedCreatorV1])),
                        },
                    },
                ],
            })).map((account) => WhitelistedCreator.from(account));
        });
    }
    getAuctionManagers(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield MetaplexProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([MetaplexKey.AuctionManagerV2])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => AuctionManager.from(account));
        });
    }
}

class AuctionWinnerTokenTypeTracker extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(MetaplexProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!AuctionWinnerTokenTypeTracker.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === MetaplexKey.AuctionWinnerTokenTypeTrackerV1;
    }
    static getPDA(auctionManager) {
        return __awaiter(this, void 0, void 0, function* () {
            return MetaplexProgram.findProgramAddress([
                Buffer$1.from(MetaplexProgram.PREFIX),
                MetaplexProgram.PUBKEY.toBuffer(),
                new PublicKey(auctionManager).toBuffer(),
                Buffer$1.from(MetaplexProgram.TOTALS),
            ]);
        });
    }
}
const deserialize = (buffer) => {
    const data = {
        key: MetaplexKey.SafetyDepositConfigV1,
        amountType: buffer[1],
        lengthType: buffer[2],
        amountRanges: [],
    };
    const lengthOfArray = new BN(buffer.slice(3, 7), 'le');
    let offset = 7;
    for (let i = 0; i < lengthOfArray.toNumber(); i++) {
        const amount = getBNFromData(buffer, offset, data.amountType);
        offset += data.amountType;
        const length = getBNFromData(buffer, offset, data.lengthType);
        offset += data.lengthType;
        data.amountRanges.push({ amount, length });
    }
    return data;
};

var VaultKey;
(function (VaultKey) {
    VaultKey[VaultKey["Uninitialized"] = 0] = "Uninitialized";
    VaultKey[VaultKey["VaultV1"] = 3] = "VaultV1";
    VaultKey[VaultKey["SafetyDepositBoxV1"] = 1] = "SafetyDepositBoxV1";
    VaultKey[VaultKey["ExternalPriceAccountV1"] = 2] = "ExternalPriceAccountV1";
})(VaultKey || (VaultKey = {}));
class VaultProgram extends Program {
}
VaultProgram.PREFIX = 'vault';
VaultProgram.PUBKEY = new PublicKey(config.programs.vault);

var _a$g;
class SafetyDepositBoxData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.SafetyDepositBoxV1;
    }
}
_a$g = SafetyDepositBoxData;
SafetyDepositBoxData.SCHEMA = _a$g.struct([
    ['key', 'u8'],
    ['vault', 'pubkeyAsString'],
    ['tokenMint', 'pubkeyAsString'],
    ['store', 'pubkeyAsString'],
    ['order', 'u8'],
]);
class SafetyDepositBox extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!SafetyDepositBox.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = SafetyDepositBoxData.deserialize(this.info.data);
    }
    static getPDA(vault, mint) {
        return __awaiter(this, void 0, void 0, function* () {
            return VaultProgram.findProgramAddress([
                Buffer$1.from(VaultProgram.PREFIX),
                new PublicKey(vault).toBuffer(),
                new PublicKey(mint).toBuffer(),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === VaultKey.SafetyDepositBoxV1;
    }
}

var _a$f, _b$2, _c;
class AmountArgs extends Data {
}
_a$f = AmountArgs;
AmountArgs.SCHEMA = _a$f.struct([
    ['instruction', 'u8'],
    ['amount', 'u8'],
]);
class NumberOfShareArgs extends Data {
}
_b$2 = NumberOfShareArgs;
NumberOfShareArgs.SCHEMA = _b$2.struct([
    ['instruction', 'u8'],
    ['numberOfShares', 'u8'],
]);
var VaultState;
(function (VaultState) {
    VaultState[VaultState["Inactive"] = 0] = "Inactive";
    VaultState[VaultState["Active"] = 1] = "Active";
    VaultState[VaultState["Combined"] = 2] = "Combined";
    VaultState[VaultState["Deactivated"] = 3] = "Deactivated";
})(VaultState || (VaultState = {}));
class VaultData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.VaultV1;
    }
}
_c = VaultData;
VaultData.SCHEMA = _c.struct([
    ['key', 'u8'],
    ['tokenProgram', 'pubkeyAsString'],
    ['fractionMint', 'pubkeyAsString'],
    ['authority', 'pubkeyAsString'],
    ['fractionTreasury', 'pubkeyAsString'],
    ['redeemTreasury', 'pubkeyAsString'],
    ['allowFurtherShareCreation', 'u8'],
    ['pricingLookupAddress', 'pubkeyAsString'],
    ['tokenTypeCount', 'u8'],
    ['state', 'u8'],
    ['lockedPricePerShare', 'u64'],
]);
class Vault extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!Vault.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = VaultData.deserialize(this.info.data);
    }
    static getPDA(pubkey) {
        return __awaiter(this, void 0, void 0, function* () {
            return VaultProgram.findProgramAddress([
                Buffer$1.from(VaultProgram.PREFIX),
                VaultProgram.PUBKEY.toBuffer(),
                new PublicKey(pubkey).toBuffer(),
            ]);
        });
    }
    static isCompatible(data) {
        return data[0] === VaultKey.VaultV1;
    }
    getSafetyDepositBoxes(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield VaultProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([VaultKey.SafetyDepositBoxV1])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => SafetyDepositBox.from(account));
        });
    }
}

var _a$e;
class ExternalPriceAccountData extends Data {
    constructor(args) {
        super(args);
        this.key = VaultKey.ExternalPriceAccountV1;
    }
}
_a$e = ExternalPriceAccountData;
ExternalPriceAccountData.SCHEMA = _a$e.struct([
    ['key', 'u8'],
    ['pricePerShare', 'u64'],
    ['priceMint', 'pubkeyAsString'],
    ['allowedToCombine', 'u8'],
]);
class ExternalPriceAccount extends Account {
    constructor(key, info) {
        super(key, info);
        if (!this.assertOwner(VaultProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!ExternalPriceAccount.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = ExternalPriceAccountData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === VaultKey.ExternalPriceAccountV1;
    }
}

class ActivateVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionMint, fractionTreasury, fractionMintAuthority, numberOfShares, } = params;
        const data = NumberOfShareArgs.serialize({ instruction: 2, numberOfShares });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMintAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class AddTokenToInactiveVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { vault, vaultAuthority, tokenAccount, tokenStoreAccount, transferAuthority, safetyDepositBox, amount, } = params;
        const data = AmountArgs.serialize({ instruction: 1, amount });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: safetyDepositBox,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenStoreAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$d;
class CombineVaultArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 3;
    }
}
_a$d = CombineVaultArgs;
CombineVaultArgs.SCHEMA = _a$d.struct([['instruction', 'u8']]);
class CombineVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionMint, fractionTreasury, outstandingShareTokenAccount, payingTokenAccount, redeemTreasury, newVaultAuthority, transferAuthority, externalPriceAccount, burnAuthority, } = params;
        const data = CombineVaultArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: outstandingShareTokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: payingTokenAccount,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: redeemTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: newVaultAuthority || vaultAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: burnAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: externalPriceAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$c;
class InitVaultArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 0;
        this.allowFurtherShareCreation = false;
    }
}
_a$c = InitVaultArgs;
InitVaultArgs.SCHEMA = _a$c.struct([
    ['instruction', 'u8'],
    ['allowFurtherShareCreation', 'u8'],
]);
class InitVault extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, fractionalMint, redeemTreasury, fractionalTreasury, pricingLookupAddress, allowFurtherShareCreation, } = params;
        const data = InitVaultArgs.serialize({ allowFurtherShareCreation });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: fractionalMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: redeemTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionalTreasury,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: pricingLookupAddress,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$b;
class SetVaultAuthorityArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 10;
    }
}
_a$b = SetVaultAuthorityArgs;
SetVaultAuthorityArgs.SCHEMA = _a$b.struct([['instruction', 'u8']]);
class SetVaultAuthority extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, currentAuthority, newAuthority } = params;
        const data = SetVaultAuthorityArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: currentAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: newAuthority,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$a;
class UpdateExternalPriceAccountArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 9;
    }
}
_a$a = UpdateExternalPriceAccountArgs;
UpdateExternalPriceAccountArgs.SCHEMA = new Map([
    ...ExternalPriceAccountData.SCHEMA,
    ..._a$a.struct([
        ['instruction', 'u8'],
        ['externalPriceAccount', ExternalPriceAccountData],
    ]),
]);
class UpdateExternalPriceAccount extends Transaction {
    constructor(options, params) {
        super(options);
        const { externalPriceAccount, externalPriceAccountData } = params;
        const data = UpdateExternalPriceAccountArgs.serialize({
            externalPriceAccount: externalPriceAccountData,
        });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: externalPriceAccount,
                    isSigner: false,
                    isWritable: true,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

class WithdrawTokenFromSafetyDepositBox extends Transaction {
    constructor(options, params) {
        super(options);
        const { vault, vaultAuthority, store, destination, fractionMint, transferAuthority, safetyDepositBox, amount, } = params;
        const data = AmountArgs.serialize({ instruction: 5, amount });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDepositBox,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vaultAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: VaultProgram.PUBKEY,
            data,
        }));
    }
}

var _a$9;
class SetStoreArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 8;
    }
}
_a$9 = SetStoreArgs;
SetStoreArgs.SCHEMA = _a$9.struct([
    ['instruction', 'u8'],
    ['public', 'u8'],
]);
class SetStore extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { admin, store, isPublic } = params;
        const data = SetStoreArgs.serialize({ public: isPublic });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: admin,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                {
                    pubkey: VaultProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: MetadataProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$8;
class SetWhitelistedCreatorArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 9;
    }
}
_a$8 = SetWhitelistedCreatorArgs;
SetWhitelistedCreatorArgs.SCHEMA = _a$8.struct([
    ['instruction', 'u8'],
    ['activated', 'u8'],
]);
class SetWhitelistedCreator extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { admin, whitelistedCreatorPDA, store, creator, activated } = params;
        const data = SetWhitelistedCreatorArgs.serialize({ activated });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: whitelistedCreatorPDA,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: admin,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: creator,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$7;
class StartAuctionArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 5;
    }
}
_a$7 = StartAuctionArgs;
StartAuctionArgs.SCHEMA = _a$7.struct([['instruction', 'u8']]);
class StartAuction extends Transaction {
    constructor(options, params) {
        super(options);
        const { store, auction, auctionManager, auctionManagerAuthority } = params;
        const data = StartAuctionArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionManagerAuthority,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$6;
class InitAuctionManagerV2Args extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 17;
        this.amountType = TupleNumericType.U8;
        this.lengthType = TupleNumericType.U8;
        this.maxRanges = new BN(1);
    }
}
_a$6 = InitAuctionManagerV2Args;
InitAuctionManagerV2Args.SCHEMA = _a$6.struct([
    ['instruction', 'u8'],
    ['amountType', 'u8'],
    ['lengthType', 'u8'],
    ['maxRanges', 'u64'],
]);
class InitAuctionManagerV2 extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { store, vault, auction, auctionManager, auctionManagerAuthority, acceptPaymentAccount, tokenTracker, amountType, lengthType, maxRanges, } = params;
        const data = InitAuctionManagerV2Args.serialize({ amountType, lengthType, maxRanges });
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: tokenTracker,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: auctionManagerAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: acceptPaymentAccount,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$5;
class ClaimBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 6;
    }
}
_a$5 = ClaimBidArgs;
ClaimBidArgs.SCHEMA = _a$5.struct([['instruction', 'u8']]);
class ClaimBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { store, vault, auction, auctionManager, bidder, bidderPot, bidderPotToken, acceptPayment, tokenMint, } = params;
        const data = ClaimBidArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: acceptPayment,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPotToken,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidderPot,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidder,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: tokenMint,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: AuctionProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_CLOCK_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var _a$4, _b$1;
class RedeemBidArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 2;
    }
}
_a$4 = RedeemBidArgs;
RedeemBidArgs.SCHEMA = _a$4.struct([['instruction', 'u8']]);
var ProxyCallAddress;
(function (ProxyCallAddress) {
    ProxyCallAddress[ProxyCallAddress["RedeemBid"] = 0] = "RedeemBid";
    ProxyCallAddress[ProxyCallAddress["RedeemFullRightsTransferBid"] = 1] = "RedeemFullRightsTransferBid";
})(ProxyCallAddress || (ProxyCallAddress = {}));
class RedeemUnusedWinningConfigItemsAsAuctioneerArgs extends Data {
    constructor() {
        super(...arguments);
        this.instruction = 12;
    }
}
_b$1 = RedeemUnusedWinningConfigItemsAsAuctioneerArgs;
RedeemUnusedWinningConfigItemsAsAuctioneerArgs.SCHEMA = _b$1.struct([
    ['instruction', 'u8'],
    ['winningConfigItemIndex', 'u8'],
    ['proxyCall', 'u8'],
]);
class RedeemBid extends Transaction {
    constructor(options, params) {
        super(options);
        const { feePayer } = options;
        const { store, vault, auction, auctionManager, bidRedemption, bidMetadata, safetyDepositTokenStore, destination, safetyDeposit, fractionMint, bidder, isPrintingType, safetyDepositConfig, transferAuthority, masterEdition, reservationList, auctioneerReclaimIndex, } = params;
        const data = auctioneerReclaimIndex
            ? RedeemUnusedWinningConfigItemsAsAuctioneerArgs.serialize({
                winningConfigItemIndex: auctioneerReclaimIndex,
                proxyCall: ProxyCallAddress.RedeemBid,
            })
            : RedeemBidArgs.serialize();
        this.add(new TransactionInstruction({
            keys: [
                {
                    pubkey: auctionManager,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDepositTokenStore,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: destination,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: bidRedemption,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: safetyDeposit,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: vault,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: fractionMint,
                    isSigner: false,
                    isWritable: true,
                },
                {
                    pubkey: auction,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidMetadata,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: bidder,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: feePayer,
                    isSigner: true,
                    isWritable: false,
                },
                {
                    pubkey: TOKEN_PROGRAM_ID,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: VaultProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: MetadataProgram.PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: store,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SystemProgram.programId,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: transferAuthority,
                    isSigner: false,
                    isWritable: false,
                },
                {
                    pubkey: safetyDepositConfig,
                    isSigner: false,
                    isWritable: false,
                },
                ...(isPrintingType && masterEdition && reservationList
                    ? [
                        {
                            pubkey: masterEdition,
                            isSigner: false,
                            isWritable: true,
                        },
                        {
                            pubkey: reservationList,
                            isSigner: false,
                            isWritable: true,
                        },
                    ]
                    : []),
            ],
            programId: MetaplexProgram.PUBKEY,
            data,
        }));
    }
}

var NFTPacksAccountType;
(function (NFTPacksAccountType) {
    NFTPacksAccountType[NFTPacksAccountType["Uninitialized"] = 0] = "Uninitialized";
    NFTPacksAccountType[NFTPacksAccountType["PackSet"] = 1] = "PackSet";
    NFTPacksAccountType[NFTPacksAccountType["PackCard"] = 2] = "PackCard";
    NFTPacksAccountType[NFTPacksAccountType["PackVoucher"] = 3] = "PackVoucher";
    NFTPacksAccountType[NFTPacksAccountType["ProvingProcess"] = 4] = "ProvingProcess";
})(NFTPacksAccountType || (NFTPacksAccountType = {}));
class NFTPacksProgram extends Program {
}
NFTPacksProgram.PREFIX = 'packs';
NFTPacksProgram.PUBKEY = new PublicKey(config.programs.packs);

var _a$3, _b;
var DistributionType;
(function (DistributionType) {
    DistributionType[DistributionType["FixedNumber"] = 0] = "FixedNumber";
    DistributionType[DistributionType["ProbabilityBased"] = 1] = "ProbabilityBased";
})(DistributionType || (DistributionType = {}));
class Distribution extends Data {
}
_a$3 = Distribution;
Distribution.SCHEMA = _a$3.struct([
    ['type', 'u8'],
    ['value', 'u64'],
]);
class PackCardData extends Data {
    constructor(args) {
        super(args);
        this.accountType = NFTPacksAccountType.PackCard;
    }
}
_b = PackCardData;
PackCardData.SCHEMA = new Map([
    ...Distribution.SCHEMA,
    ..._b.struct([
        ['accountType', 'u8'],
        ['packSet', 'pubkeyAsString'],
        ['master', 'pubkeyAsString'],
        ['metadata', 'pubkeyAsString'],
        ['tokenAccount', 'pubkeyAsString'],
        ['maxSupply', { kind: 'option', type: 'u32' }],
        ['distribution', Distribution],
        ['currentSupply', 'u32'],
    ]),
]);
class PackCard extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(NFTPacksProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PackCard.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PackCardData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === NFTPacksAccountType.PackCard;
    }
    static getPDA(packSet, index) {
        return NFTPacksProgram.findProgramAddress([
            Buffer$1.from(PackCard.PREFIX),
            new PublicKey(packSet).toBuffer(),
            Buffer$1.from(index.toString()),
        ]);
    }
}
PackCard.PREFIX = 'card';

var _a$2;
var PackSetState;
(function (PackSetState) {
    PackSetState[PackSetState["NotActivated"] = 0] = "NotActivated";
    PackSetState[PackSetState["Activated"] = 1] = "Activated";
    PackSetState[PackSetState["Deactivated"] = 2] = "Deactivated";
})(PackSetState || (PackSetState = {}));
class PackSetData extends Data {
    constructor(args) {
        super(args);
        this.accountType = NFTPacksAccountType.PackSet;
        this.name = String.fromCharCode.apply(null, args.name).replace(/\0.*$/g, '');
        this.state = args.state;
    }
}
_a$2 = PackSetData;
PackSetData.SCHEMA = _a$2.struct([
    ['accountType', 'u8'],
    ['name', [32]],
    ['authority', 'pubkeyAsString'],
    ['mintingAuthority', 'pubkeyAsString'],
    ['totalPacks', 'u32'],
    ['packCards', 'u32'],
    ['packVouchers', 'u32'],
    ['mutable', 'u8'],
    ['state', 'u8'],
]);
class PackSet extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(NFTPacksProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PackSet.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PackSetData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === NFTPacksAccountType.PackSet;
    }
    getCards(connection) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield NFTPacksProgram.getProgramAccounts(connection, {
                filters: [
                    {
                        memcmp: {
                            offset: 0,
                            bytes: bs58.encode(Buffer$1.from([NFTPacksAccountType.PackCard])),
                        },
                    },
                    {
                        memcmp: {
                            offset: 1,
                            bytes: this.pubkey.toBase58(),
                        },
                    },
                ],
            })).map((account) => PackCard.from(account));
        });
    }
}

var _a$1;
var ActionOnProve;
(function (ActionOnProve) {
    ActionOnProve[ActionOnProve["Burn"] = 0] = "Burn";
    ActionOnProve[ActionOnProve["Redeem"] = 1] = "Redeem";
})(ActionOnProve || (ActionOnProve = {}));
class PackVoucherData extends Data {
    constructor(args) {
        super(args);
        this.accountType = NFTPacksAccountType.PackVoucher;
    }
}
_a$1 = PackVoucherData;
PackVoucherData.SCHEMA = _a$1.struct([
    ['accountType', 'u8'],
    ['packSet', 'pubkeyAsString'],
    ['master', 'pubkeyAsString'],
    ['metadata', 'pubkeyAsString'],
    ['tokenAccount', 'pubkeyAsString'],
    ['maxSupply', { kind: 'option', type: 'u32' }],
    ['currentSupply', 'u32'],
    ['numberToOpen', 'u32'],
    ['actionOnProve', 'u8'],
]);
class PackVoucher extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(NFTPacksProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!PackVoucher.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = PackVoucherData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === NFTPacksAccountType.PackVoucher;
    }
    static getPDA(packSet, index) {
        return NFTPacksProgram.findProgramAddress([
            Buffer$1.from(PackVoucher.PREFIX),
            new PublicKey(packSet).toBuffer(),
            Buffer$1.from(index.toString()),
        ]);
    }
}
PackVoucher.PREFIX = 'voucher';

var _a;
class ProvingProcessData extends Data {
    constructor(args) {
        super(args);
        this.accountType = NFTPacksAccountType.ProvingProcess;
    }
}
_a = ProvingProcessData;
ProvingProcessData.SCHEMA = _a.struct([
    ['accountType', 'u8'],
    ['userWallet', 'pubkeyAsString'],
    ['packSet', 'pubkeyAsString'],
    ['provedVouchers', 'u32'],
    ['provedVoucherEditions', 'u32'],
    ['claimedCards', 'u32'],
    ['claimedCardEditions', 'u32'],
]);
class ProvingProcess extends Account {
    constructor(pubkey, info) {
        super(pubkey, info);
        if (!this.assertOwner(NFTPacksProgram.PUBKEY)) {
            throw ERROR_INVALID_OWNER();
        }
        if (!ProvingProcess.isCompatible(this.info.data)) {
            throw ERROR_INVALID_ACCOUNT_DATA();
        }
        this.data = ProvingProcessData.deserialize(this.info.data);
    }
    static isCompatible(data) {
        return data[0] === NFTPacksAccountType.ProvingProcess;
    }
    static getPDA(packSet, userWallet) {
        return NFTPacksProgram.findProgramAddress([
            Buffer$1.from(ProvingProcess.PREFIX),
            new PublicKey(packSet).toBuffer(),
            new PublicKey(userWallet).toBuffer(),
        ]);
    }
}
ProvingProcess.PREFIX = 'proving';

const initStore = ({ connection, wallet, isPublic = true, }) => __awaiter(void 0, void 0, void 0, function* () {
    const storeId = yield Store.getPDA(wallet.publicKey);
    const tx = new SetStore({ feePayer: wallet.publicKey }, {
        admin: new PublicKey(wallet.publicKey),
        store: storeId,
        isPublic,
    });
    const txId = yield sendTransaction({ connection, wallet, txs: [tx] });
    return { storeId, txId };
});

const mintNFT = () => __awaiter(void 0, void 0, void 0, function* () {
    throw new Error("It's not implemented");
});

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sendTransaction: sendTransaction,
  initStore: initStore,
  mintNFT: mintNFT
});

var Currency;
(function (Currency) {
    Currency["USD"] = "usd";
    Currency["EUR"] = "eur";
    Currency["AR"] = "ar";
    Currency["SOL"] = "sol";
})(Currency || (Currency = {}));
class ConversionRateProvider {
}

class Coingecko {
    constructor() { }
    static translateCurrency(currency) {
        switch (currency) {
            case Currency.AR:
                return 'arweave';
            case Currency.SOL:
                return 'solana';
            case Currency.USD:
                return 'usd';
            case Currency.EUR:
                return 'eur';
            default:
                throw new Error('Invalid currency supplied to Coingecko conversion rate provider');
        }
    }
    getRate(from, to) {
        return __awaiter(this, void 0, void 0, function* () {
            const fromArray = typeof from === 'string' ? [from] : from;
            const toArray = typeof to === 'string' ? [to] : to;
            const fromIds = fromArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');
            const toIds = toArray.map((currency) => Coingecko.translateCurrency(currency)).join(',');
            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${fromIds}&vs_currencies=${toIds}`;
            const response = yield axios(url);
            const data = yield response.data;
            return fromArray.reduce((previousPairs, fromCurrency) => {
                return [
                    ...previousPairs,
                    ...toArray.map((toCurrency) => ({
                        from: fromCurrency,
                        to: toCurrency,
                        rate: data[Coingecko.translateCurrency(fromCurrency)][Coingecko.translateCurrency(toCurrency)],
                    })),
                ];
            }, []);
        });
    }
}

/* eslint-env browser */

var browser = typeof self == 'object' ? self.FormData : window.FormData;

const ARWEAVE_URL = 'https://arweave.net';
const LAMPORT_MULTIPLIER = Math.pow(10, 9);
const WINSTON_MULTIPLIER = Math.pow(10, 12);
class ArweaveStorage {
    constructor({ endpoint, env }) {
        this.endpoint = endpoint;
        this.env = env;
    }
    getAssetCostToStore(files, arweaveRate, solanaRate) {
        return __awaiter(this, void 0, void 0, function* () {
            const buffers = Array.from(files.values());
            const totalBytes = buffers.reduce((sum, f) => (sum += f.byteLength), 0);
            const txnFeeInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/0`)).data);
            const byteCostInWinstons = parseInt(yield (yield axios(`${ARWEAVE_URL}/price/${totalBytes.toString()}`)).data);
            const totalArCost = (txnFeeInWinstons * buffers.length + byteCostInWinstons) / WINSTON_MULTIPLIER;
            const arMultiplier = arweaveRate / solanaRate;
            return LAMPORT_MULTIPLIER * totalArCost * arMultiplier * 1.1;
        });
    }
    upload(files, mintKey, txid) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileEntries = Array.from(files.entries());
            const tags = fileEntries.reduce((acc, [fileName]) => {
                acc[fileName] = [{ name: 'mint', value: mintKey }];
                return acc;
            }, {});
            const body = new browser();
            body.append('tags', JSON.stringify(tags));
            body.append('transaction', txid);
            body.append('env', this.env);
            fileEntries.map(([, file]) => {
                body.append('file[]', file);
            });
            const response = yield axios.post(this.endpoint, body);
            if (response.data.error) {
                return Promise.reject(new Error(response.data.error));
            }
            return response.data;
        });
    }
}

var ChainId;
(function (ChainId) {
    ChainId[ChainId["MainnetBeta"] = 101] = "MainnetBeta";
    ChainId[ChainId["Testnet"] = 102] = "Testnet";
    ChainId[ChainId["Devnet"] = 103] = "Devnet";
})(ChainId || (ChainId = {}));
const ENV = {
    devnet: {
        endpoint: clusterApiUrl('devnet'),
        ChainId: ChainId.Devnet,
    },
    'mainnet-beta': {
        endpoint: 'https://api.metaplex.solana.com/',
        ChainId: ChainId.MainnetBeta,
    },
    'mainnet-beta (Solana)': {
        endpoint: 'https://api.mainnet-beta.solana.com',
        ChainId: ChainId.MainnetBeta,
    },
    'mainnet-beta (Serum)': {
        endpoint: 'https://solana-api.projectserum.com/',
        ChainId: ChainId.MainnetBeta,
    },
    testnet: {
        endpoint: clusterApiUrl('testnet'),
        ChainId: ChainId.Testnet,
    },
};
class Connection extends Connection$1 {
    constructor(endpoint = 'mainnet-beta', commitment) {
        if (endpoint in ENV)
            endpoint = ENV[endpoint].endpoint;
        super(endpoint, commitment);
    }
}

class NodeWallet {
    constructor(payer) {
        this.payer = payer;
    }
    signTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            tx.partialSign(this.payer);
            return tx;
        });
    }
    signAllTransactions(txs) {
        return __awaiter(this, void 0, void 0, function* () {
            return txs.map((tx) => {
                tx.partialSign(this.payer);
                return tx;
            });
        });
    }
    get publicKey() {
        return this.payer.publicKey;
    }
}

export { ActionOnProve, index as Actions, ActivateVault, AddTokenToInactiveVault, AmountArgs, ArweaveStorage, Auction, AuctionData, AuctionDataExtended, AuctionExtended, AuctionManager, AuctionManagerStateV2, AuctionManagerStatus, AuctionManagerV2Data, AuctionProgram, AuctionState, AuctionWinnerTokenTypeTracker, Bid, BidRedemptionTicket, BidState, BidStateType, BidderMetadata, BidderMetadataData, BidderPot, BidderPotData, CancelBid, CancelBidArgs, ChainId, ClaimBid, ClaimBidArgs, Coingecko, CombineVault, CombineVaultArgs, Connection, ConversionRateProvider, CreateAssociatedTokenAccount, CreateAuction, CreateAuctionArgs, CreateMasterEdition, CreateMasterEditionArgs, CreateMetadata, CreateMetadataArgs, CreateMint, CreateTokenAccount, Creator, Currency, Distribution, DistributionType, ENV, Edition, EditionData, EditionMarker, EditionMarkerData, errors as Errors, ExternalPriceAccount, ExternalPriceAccountData, InitAuctionManagerV2, InitAuctionManagerV2Args, InitVault, InitVaultArgs, MAX_CREATOR_LEN, MAX_NAME_LENGTH, MAX_SYMBOL_LENGTH, MAX_URI_LENGTH, MasterEdition, MasterEditionV1Data, MasterEditionV2Data, Metadata, MetadataData, MetadataDataData, MetadataKey, MetadataProgram, MetaplexKey, MetaplexProgram, MintNewEditionFromMasterEditionViaToken, MintNewEditionFromMasterEditionViaTokenArgs, MintTo, NFTPacksAccountType, NFTPacksProgram, NodeWallet, NonWinningConstraint, NumberOfShareArgs, PackCard, PackCardData, PackSet, PackSetData, PackSetState, PackVoucher, PackVoucherData, PayForFiles, PayoutTicket, PayoutTicketData, PlaceBid, PlaceBidArgs, PriceFloor, PriceFloorType, PrizeTrackingTicket, PrizeTrackingTicketData, ProvingProcess, ProvingProcessData, ProxyCallAddress, RedeemBid, RedeemBidArgs, RedeemUnusedWinningConfigItemsAsAuctioneerArgs, SafetyDepositBox, SafetyDepositBoxData, SafetyDepositConfig, SetAuctionAuthority, SetAuctionAuthorityArgs, SetStore, SetStoreArgs, SetVaultAuthority, SetVaultAuthorityArgs, SetWhitelistedCreator, SetWhitelistedCreatorArgs, SignMetadata, SignMetadataArgs, StartAuction, StartAuctionArgs, Store, StoreData, TokenAccount, Transaction, UpdateExternalPriceAccount, UpdateExternalPriceAccountArgs, UpdateMetadata, UpdateMetadataArgs, UpdatePrimarySaleHappenedViaToken, UpdatePrimarySaleHappenedViaTokenArgs, index$1 as Utils, Vault, VaultData, VaultKey, VaultProgram, VaultState, WINNER_INDEX_OFFSETS, WhitelistedCreator, WhitelistedCreatorData, WinnerLimit, WinnerLimitType, WinningConfigType, WinningConstraint, WithdrawTokenFromSafetyDepositBox, computeCreatorOffset, deserialize$2 as deserialize };
//# sourceMappingURL=index.browser.esm.js.map
