"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keys = exports.arweave = void 0;
const tslib_1 = require("tslib");
const api_1 = (0, tslib_1.__importDefault)(require("arweave/node/lib/api"));
const utils_1 = (0, tslib_1.__importDefault)(require("./utils"));
const withdrawal_1 = require("./withdrawal");
const upload_1 = (0, tslib_1.__importDefault)(require("./upload"));
const fund_1 = (0, tslib_1.__importDefault)(require("./fund"));
const transaction_1 = (0, tslib_1.__importDefault)(require("./transaction"));
let currencies;
exports.keys = {};
// export enum Currencies {
//     ARWEAVE = "arweave",
//     SOLANA = "solana",
//     AVALANCHE = "avalanche",
//     MATIC = "matic"
// }
// export interface ApiConfig {
//     host?: string;
//     protocol?: string;
//     port?: string | number;
//     timeout?: number;
//     logging?: boolean;
//     logger?: Function;
//   }
class Bundlr {
    /**
     * Constructs a new Bundlr instance, as well as supporting subclasses
     * @param url - URL to the bundler
     * @param wallet - JWK in JSON
     */
    constructor(url, currency, wallet) {
        // hacky for the moment...
        // specifically about ordering - some stuff here seems silly but leave it for now it works
        this.currency = currency;
        if (!wallet) {
            wallet = "default";
        }
        exports.keys[currency] = { key: wallet, address: undefined };
        this.wallet = wallet;
        const parsed = new URL(url);
        this.api = new api_1.default({ protocol: parsed.protocol.slice(0, -1), port: parsed.port, host: parsed.hostname }); //borrow their nice Axios API :p
        // if (currency === "arweave") {
        //     //arweave = new Arweave(this.api.getConfig());
        //     arweave = Arweave.init({ host: "arweave.net", protocol: "https", port: 443 });
        // }
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        currencies = (require("./currencies/index")).currencies; //delay so that keys object can be properly constructed
        if (!currencies[currency]) {
            throw new Error(`Unknown/Unsuported currency ${currency}`);
        }
        this.currencyConfig = currencies[currency];
        if (!(wallet === "default")) {
            this.address = this.currencyConfig.ownerToAddress(this.currencyConfig.getPublicKey());
        }
        this.currencyConfig.account.address = this.address;
        //this.address = address;
        this.utils = new utils_1.default(this.api, this.currency, this.currencyConfig, { address: this.address, wallet });
        // this.withdrawBalance = async (amount: number) => await withdrawBalance(this.utils, this.api, wallet, amount);
        this.uploader = new upload_1.default(this.api, currency, this.currencyConfig);
        // this.upload = this.uploader.upload; note to self: don't do this, this destorys 'this' scoping for instantiated subclasses
        this.funder = new fund_1.default(this.utils);
    }
    withdrawBalance(amount) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return yield (0, withdrawal_1.withdrawBalance)(this.utils, this.api, amount);
        });
    }
    /**
     * Gets the balance for the loaded wallet
     * @returns balance (in winston)
     */
    getLoadedBalance() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return this.utils.getBalance(this.address);
        });
    }
    /**
     * Gets the balance for the specified address
     * @param address address to query for
     * @returns the balance (in winston)
     */
    getBalance(address) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return this.utils.getBalance(address);
        });
    }
    /**
     * Sends amount winston to the specified bundler
     * @param amount amount to send in winston
     * @returns Arweave transaction
     */
    fund(amount, multiplier) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return this.funder.fund(amount, multiplier);
        });
    }
    /**
     * Upload a file at the specified path to the bundler
     * @param path path to the file to upload
     * @returns bundler response
     */
    uploadFile(path) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            return this.uploader.uploadFile(path);
        });
    }
    ;
    /**
     * Create a new BundlrTransactions (flex currency arbundles dataItem)
     * @param data
     * @param opts - dataItemCreateOptions
     * @returns - a new BundlrTransaction instance
     */
    createTransaction(data, opts) {
        return new transaction_1.default(data, this, opts);
    }
}
exports.default = Bundlr;
//# sourceMappingURL=bundlr.js.map