"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldRefreshToken = void 0;
const react_1 = require("react");
const config_1 = require("../solana/config");
const logger_1 = __importDefault(require("../logger"));
const types_1 = require("../types");
const useChain_1 = __importDefault(require("./useChain"));
const useRefresh_1 = __importDefault(require("./useRefresh"));
const useWalletHooks_1 = __importDefault(require("./useWalletHooks"));
const actionCreator_1 = require("../actionCreator");
const usePOWO_1 = __importDefault(require("./usePOWO"));
const useGatekeeper_1 = __importDefault(require("./useGatekeeper"));
const useGatekeeperRecord_1 = __importDefault(require("./useGatekeeperRecord"));
const shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {
    if (!gatewayToken)
        return false;
    if (gatewayToken.state !== types_1.State.ACTIVE)
        return false;
    if (!useWallet || !useWallet.publicKey || powoRequested)
        return false;
    return state !== types_1.GatekeeperRecordState.ISSUED;
};
exports.shouldRefreshToken = shouldRefreshToken;
/**
 * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:
 * 1. the creation of a new gateway token for a new user
 * 2. the refreshing of an existing token for an existing user
 *
 * The orchestrator triggers uses effects to trigger flows for these two scenarios
 *
 * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0
 * @param {Partial<RootState>} state
 * @param {React.Dispatch<Action>} dispatch
 * @returns void
 */
const useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {
    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);
    const gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage);
    // Register our hooks here
    const { setRefreshPoll, refreshTokenWithProof } = (0, useRefresh_1.default)({ stage, gatekeeperClient }, state, dispatch);
    const { waitForConfirmPOWO, waitForPOWO } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);
    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);
    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig }, state, dispatch);
    (0, useChain_1.default)({ wallet, chainImplementation }, state, dispatch);
    const { gatewayToken, tokenRequested, refreshIntervalId, powoRequested, refreshInProgress, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, } = state;
    /**
     * Refresh Flows ----------------------------------------------------------------
     */
    /**
     * wait until we have a payload that has been emitted by the CivicPass iframe
     * then resolve the promise
     */
    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');
        const result = new Promise((resolve) => {
            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;
            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];
            logger_1.default.debug('Refresh payload...', refreshPayload);
            if (refreshPayload) {
                resolve(refreshPayload);
            }
        });
        return result;
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);
    /**
     * wait until a gateway token exists in state before resolving the promise
     */
    const waitForGatewayToken = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        return new Promise((resolve) => {
            logger_1.default.debug('waitForGatewayToken gatewayToken', !!gatewayToken);
            if (gatewayToken)
                resolve(gatewayToken);
        });
    }, [gatewayToken, expectWalletConnected]);
    const checkRefreshRequired = (0, react_1.useCallback)(async (connectedWallet) => {
        const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect
        // Check preconditions for refresh:
        await waitForGatewayToken();
        if (!gatewayToken)
            return;
        const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);
        const shouldRefresh = await (0, exports.shouldRefreshToken)(record.state, gatewayToken, useWallet, powoRequested);
        dispatch({ type: 'getGatekeeperRecord_success', gatekeeperRecord: record });
        if (!shouldRefresh) {
            logger_1.default.debug('Refresh not needed. Skipping this attempt.');
            dispatch({ type: 'refresh_complete' });
            setRefreshPoll(useWallet);
            return;
        }
        logger_1.default.debug('Refresh required. Running the refresh flow.');
        clearInterval(refreshIntervalId);
        dispatch({ type: 'refresh_start' });
        dispatch({ type: 'civicPass_check_token_status' });
        dispatch({ type: 'refresh_clear_interval' });
    }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);
    /**
     * Check if the user needs to refresh their roken
     */
    (0, react_1.useEffect)(() => {
        if (refreshTokenState === types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION) {
            logger_1.default.debug('Checking if refresh required');
            checkRefreshRequired();
        }
    }, [refreshTokenState]);
    /**
     * If the user cancels out of the refresh flow start the refresh interval
     */
    (0, react_1.useEffect)(() => {
        if (refreshTokenState === types_1.RefreshTokenState.CANCELLED || refreshTokenState === types_1.RefreshTokenState.FAILED) {
            logger_1.default.debug('User canceled out of the refresh flow');
            setRefreshPoll(wallet);
        }
    }, [refreshTokenState]);
    /**
     * When we have a token start polling to determine the refresh state
     */
    (0, react_1.useEffect)(() => {
        if (gatewayStatus === types_1.GatewayStatus.ACTIVE) {
            logger_1.default.debug('Start polling for the record');
            setRefreshPoll(wallet);
        }
    }, [gatewayStatus]);
    /**
     * Issuance Flows ----------------------------------------------------------------
     */
    /**
     * poll until a gatekeeper record is found, once active check the chain for a token
     * then dispatch a tokenChange event that will result in the token getting saved to state
     * start token refresh polling once a valid token is set
     */
    const waitForCreatedGatekeeperRecord = (0, react_1.useCallback)(async () => {
        if (wallet) {
            logger_1.default.debug('waitForCreatedGatekeeperRecord');
            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({
                gatekeeperClient,
                wallet,
                chainImplementation,
                dispatch,
            });
            await actionCreator.waitForGatewayToken();
        }
        return null;
    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);
    /**
     * wait until a presentation request id has been emitted by the CivicPass iframe
     * then resolve the promise
     */
    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');
        const result = new Promise((resolve) => {
            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;
            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];
            logger_1.default.debug('Issuance payload...', issuancePayload);
            if (issuancePayload !== undefined && issuancePayload.requiresProofOfWalletOwnership) {
                resolve(issuancePayload);
            }
        });
        return result;
    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);
    /**
     * wait until the user has requested a gateway token before resolving the promise
     */
    const waitForTokenRequested = (0, react_1.useCallback)(() => {
        expectWalletConnected();
        return new Promise((resolve) => {
            logger_1.default.debug('waitForTokenRequested tokenRequested', tokenRequested);
            if (tokenRequested)
                resolve(true);
        });
    }, [tokenRequested, expectWalletConnected]);
    /**
     * wait until the user has requested a gateway token before resolving the promise
     */
    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {
        if (requiresProofOfWalletOwnership) {
            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);
            return result;
        }
        return { proof: null, payload };
    }, [waitForConfirmPOWO, waitForPOWO]);
    /**
     * New token request flow:
     * wait for the user to request a new token
     * wait for the iframe to return a payload
     * wait for the user to confirm they've read the proof of ownership dialogue
     * wait for the user to provide proof of ownership
     * wait for a call to the gatekeeper to request a new token issuance
     * wait for a gatekeeper record to be created
     * once this flow is complete a new Gatekeeper token should be available and set in state
     */
    (0, react_1.useEffect)(() => {
        if (wallet && wallet.publicKey) {
            logger_1.default.debug('newTokenRequestFlow');
            waitForTokenRequested()
                .then(waitForCivicPassIssuanceResponsePayload)
                .then(checkForRequiredProof)
                .then(waitForGatekeeperIssuanceRequest)
                .then(waitForCreatedGatekeeperRecord)
                .then(() => setRefreshPoll(wallet))
                .catch((error) => logger_1.default.error('ERROR newTokenRequestFlow', error));
        }
    }, [
        waitForTokenRequested,
        waitForCivicPassIssuanceResponsePayload,
        checkForRequiredProof,
        waitForGatekeeperIssuanceRequest,
        waitForCreatedGatekeeperRecord,
    ]);
    /**
     * Refresh flow:
     * wait refresh to be triggered from the iFrame
     * wait for the iframe to return a payload
     * wait for the user to confirm they've read the proof of ownership dialogue
     * wait for the user to provide proof of ownership
     * wait for a call to the gatekeeper to refresh the token
     * start the polling interval
     */
    const refreshFlow = (0, react_1.useCallback)(async (connectedWallet) => {
        const useWallet = walletToRefresh || connectedWallet;
        // Do the refresh flow.
        waitForCivicPassRefreshResponsePayload()
            .then(checkForRequiredProof)
            .then(refreshTokenWithProof(useWallet))
            .then(() => setRefreshPoll(useWallet))
            .then(() => {
            dispatch({ type: 'refresh_complete' });
        })
            .catch((error) => {
            logger_1.default.error('refreshFlow', error);
            logger_1.default.error('refreshToken error', error);
            dispatch({ type: 'refresh_complete' });
            setRefreshPoll(useWallet);
        });
    }, [
        gatekeeperEndpoint,
        gatewayToken,
        powoRequested,
        refreshInProgress,
        waitForConfirmPOWO,
        waitForGatewayToken,
        waitForPOWO,
        wallet,
        walletToRefresh,
        checkForRequiredProof,
    ]);
    /**
     * Start the refresh flow
     */
    (0, react_1.useEffect)(() => {
        if (refreshTokenState === types_1.RefreshTokenState.REQUIRES_POWO) {
            logger_1.default.debug('Start the refresh flow');
            refreshFlow(wallet);
        }
    }, [wallet, refreshTokenState]);
};
exports.default = useOrchestration;
